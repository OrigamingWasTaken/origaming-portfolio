import "./chunk-X7HCJ7ZS.js";
import "./chunk-AYNHEKRI.js";
import {
  writable
} from "./chunk-UTIALTTK.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  check_outros,
  children,
  claim_element,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  safe_not_equal,
  setContext,
  set_style,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-DCE4O3CF.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-V6TY7KAL.js";

// node_modules/svelte-transition/dist/Transition.svelte
var file = "node_modules/svelte-transition/dist/Transition.svelte";
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(144:41) {#if mounted}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let transition_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*mounted*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        div,
        "display",
        /*display*/
        ctx[1]
      );
      add_location(div, file, 143, 0, 3799);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(transition_action = /*transition*/
        ctx[3].call(
          null,
          div,
          /*show*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*mounted*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*mounted*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (transition_action && is_function(transition_action.update) && dirty & /*show*/
      1) transition_action.update.call(
        null,
        /*show*/
        ctx2[0]
      );
      if (dirty & /*display*/
      2) {
        set_style(
          div,
          "display",
          /*display*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var key = {};
function classes(classes2) {
  return classes2 ? classes2.split(" ").filter((x) => x) : [];
}
function nextFrame() {
  const raf = requestAnimationFrame;
  return new Promise((resolve) => raf(() => raf(resolve)));
}
function instance($$self, $$props, $$invalidate) {
  let enterClasses;
  let enterFromClasses;
  let enterToClasses;
  let leaveClasses;
  let leaveFromClasses;
  let leaveToClasses;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Transition", slots, ["default"]);
  let { show = null } = $$props;
  let { appear = false } = $$props;
  let { unmount = false } = $$props;
  let { enter = "" } = $$props;
  let { enterFrom = "" } = $$props;
  let { enterTo = "" } = $$props;
  let { leave = null } = $$props;
  let { leaveFrom = null } = $$props;
  let { leaveTo = null } = $$props;
  const parent = show === null ? getContext(key) : null;
  const { subscribe, set } = writable(show);
  const context = {
    appear: parent ? parent.appear : appear,
    count: 0,
    show: { subscribe },
    completed: () => {
    }
  };
  let display = show && !context.appear ? "contents" : "none";
  let mounted = !unmount || show === true;
  setContext(key, context);
  const dispatch = createEventDispatcher();
  function transition(node, show2) {
    let el;
    function addClasses(...classes2) {
      el.classList.add(...classes2);
    }
    function removeClasses(...classes2) {
      el.classList.remove(...classes2);
    }
    function transitionEnd(transitions) {
      return transitions.length ? new Promise((resolve) => el.addEventListener(
        "transitionend",
        (e) => {
          e.stopPropagation();
          resolve();
        },
        { once: true }
      )) : Promise.resolve();
    }
    function childrenCompleted(parentCompleted) {
      return context.count ? new Promise((resolve) => {
        let count = 0;
        context.completed = () => {
          if (++count === context.count) {
            resolve();
          }
          return parentCompleted;
        };
      }) : Promise.resolve();
    }
    async function apply(show3, base, from, to) {
      el = await ensureMountedElement();
      let resolveCompleted = () => {
      };
      const completed = new Promise((resolve) => {
        resolveCompleted = resolve;
      });
      const children2 = childrenCompleted(completed);
      set(show3);
      addClasses(...base, ...from);
      const transitioned = transitionEnd(base);
      await nextFrame();
      removeClasses(...from);
      addClasses(...to);
      await Promise.all([transitioned, children2]);
      if (parent) {
        await parent.completed();
      }
      removeClasses(...base, ...to);
      resolveCompleted();
    }
    async function ensureMountedElement() {
      if (unmount && !mounted) {
        $$invalidate(2, mounted = true);
        await tick();
      }
      return node.firstElementChild;
    }
    async function enter2() {
      dispatch("before-enter");
      $$invalidate(1, display = "contents");
      await apply(true, enterClasses, enterFromClasses, enterToClasses);
      dispatch("after-enter");
    }
    async function leave2() {
      dispatch("before-leave");
      await apply(false, leaveClasses, leaveFromClasses, leaveToClasses);
      $$invalidate(1, display = "none");
      if (unmount) {
        $$invalidate(2, mounted = false);
      }
      dispatch("after-leave");
    }
    let run = context.appear;
    function execute(show3) {
      executing = run ? show3 ? enter2() : leave2() : Promise.resolve();
      run = true;
    }
    let unsubscribe;
    let executing;
    if (parent) {
      parent.count++;
      unsubscribe = parent.show.subscribe(execute);
    } else {
      execute(show2);
    }
    return {
      update(show3) {
        executing.then(() => execute(show3));
      },
      destroy() {
        if (parent) {
          unsubscribe();
          parent.count--;
        }
      }
    };
  }
  const writable_props = [
    "show",
    "appear",
    "unmount",
    "enter",
    "enterFrom",
    "enterTo",
    "leave",
    "leaveFrom",
    "leaveTo"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Transition> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("show" in $$props2) $$invalidate(0, show = $$props2.show);
    if ("appear" in $$props2) $$invalidate(4, appear = $$props2.appear);
    if ("unmount" in $$props2) $$invalidate(5, unmount = $$props2.unmount);
    if ("enter" in $$props2) $$invalidate(6, enter = $$props2.enter);
    if ("enterFrom" in $$props2) $$invalidate(7, enterFrom = $$props2.enterFrom);
    if ("enterTo" in $$props2) $$invalidate(8, enterTo = $$props2.enterTo);
    if ("leave" in $$props2) $$invalidate(9, leave = $$props2.leave);
    if ("leaveFrom" in $$props2) $$invalidate(10, leaveFrom = $$props2.leaveFrom);
    if ("leaveTo" in $$props2) $$invalidate(11, leaveTo = $$props2.leaveTo);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    key,
    classes,
    nextFrame,
    getContext,
    setContext,
    createEventDispatcher,
    tick,
    writable,
    show,
    appear,
    unmount,
    enter,
    enterFrom,
    enterTo,
    leave,
    leaveFrom,
    leaveTo,
    parent,
    subscribe,
    set,
    context,
    display,
    mounted,
    dispatch,
    transition,
    leaveToClasses,
    leaveFromClasses,
    leaveClasses,
    enterToClasses,
    enterFromClasses,
    enterClasses
  });
  $$self.$inject_state = ($$props2) => {
    if ("show" in $$props2) $$invalidate(0, show = $$props2.show);
    if ("appear" in $$props2) $$invalidate(4, appear = $$props2.appear);
    if ("unmount" in $$props2) $$invalidate(5, unmount = $$props2.unmount);
    if ("enter" in $$props2) $$invalidate(6, enter = $$props2.enter);
    if ("enterFrom" in $$props2) $$invalidate(7, enterFrom = $$props2.enterFrom);
    if ("enterTo" in $$props2) $$invalidate(8, enterTo = $$props2.enterTo);
    if ("leave" in $$props2) $$invalidate(9, leave = $$props2.leave);
    if ("leaveFrom" in $$props2) $$invalidate(10, leaveFrom = $$props2.leaveFrom);
    if ("leaveTo" in $$props2) $$invalidate(11, leaveTo = $$props2.leaveTo);
    if ("display" in $$props2) $$invalidate(1, display = $$props2.display);
    if ("mounted" in $$props2) $$invalidate(2, mounted = $$props2.mounted);
    if ("leaveToClasses" in $$props2) leaveToClasses = $$props2.leaveToClasses;
    if ("leaveFromClasses" in $$props2) leaveFromClasses = $$props2.leaveFromClasses;
    if ("leaveClasses" in $$props2) leaveClasses = $$props2.leaveClasses;
    if ("enterToClasses" in $$props2) enterToClasses = $$props2.enterToClasses;
    if ("enterFromClasses" in $$props2) enterFromClasses = $$props2.enterFromClasses;
    if ("enterClasses" in $$props2) enterClasses = $$props2.enterClasses;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*enter*/
    64) {
      $: enterClasses = classes(enter);
    }
    if ($$self.$$.dirty & /*enterFrom*/
    128) {
      $: enterFromClasses = classes(enterFrom);
    }
    if ($$self.$$.dirty & /*enterTo*/
    256) {
      $: enterToClasses = classes(enterTo);
    }
    if ($$self.$$.dirty & /*leave, enter*/
    576) {
      $: leaveClasses = classes(leave === null ? enter : leave);
    }
    if ($$self.$$.dirty & /*leaveFrom, enterTo*/
    1280) {
      $: leaveFromClasses = classes(leaveFrom === null ? enterTo : leaveFrom);
    }
    if ($$self.$$.dirty & /*leaveTo, enterFrom*/
    2176) {
      $: leaveToClasses = classes(leaveTo === null ? enterFrom : leaveTo);
    }
  };
  return [
    show,
    display,
    mounted,
    transition,
    appear,
    unmount,
    enter,
    enterFrom,
    enterTo,
    leave,
    leaveFrom,
    leaveTo,
    $$scope,
    slots
  ];
}
var Transition = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      show: 0,
      appear: 4,
      unmount: 5,
      enter: 6,
      enterFrom: 7,
      enterTo: 8,
      leave: 9,
      leaveFrom: 10,
      leaveTo: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Transition",
      options,
      id: create_fragment.name
    });
  }
  get show() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appear() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appear(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unmount() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unmount(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enter() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enter(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enterFrom() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enterFrom(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enterTo() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enterTo(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leave() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leave(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leaveFrom() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leaveFrom(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leaveTo() {
    throw new Error("<Transition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leaveTo(value) {
    throw new Error("<Transition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Transition_default = Transition;
export {
  Transition_default as Transition,
  Transition_default as default
};
//# sourceMappingURL=svelte-transition.js.map
